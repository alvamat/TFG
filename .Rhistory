acres <- filter(data, ACR>2, AGS>5);acres
which(acres)
acres <- filter(data, x=ACR>2, y=AGS>5);acres
acres <- transform(data, x=ACR>2, y=AGS>5);acres
acres <- filter(data, ACR>2, AGS>5);acres
acres <- filter(agricultureLogical, x=ACR>2, y=AGS>5);agricultureLogical
agricultureLogical <- filter(acres, x=ACR>2, y=AGS>5);agricultureLogical
which(agricultureLogical)
agricultureLogical <- transform(acres, x=ACR>2, y=AGS>5);agricultureLogical
which(agricultureLogical)
agricultureLogical <- transform(data, x=ACR>2, y=AGS>5);agricultureLogical
which(agricultureLogical)
fileurl1="https://d396qusza40orc.cloudfront.net/getdata%2Fjeff.jpg"
download.file(fileurl1, destfile="./foto.jpg")
foto<- read.csv("./foto.jpg")
fileurl1="https://d396qusza40orc.cloudfront.net/getdata%2Fjeff.jpg"
download.file(fileurl1, destfile="./foto.jpg")
foto<- read.table("./foto.jpg")
fileurl1="https://d396qusza40orc.cloudfront.net/getdata%2Fjeff.jpg"
download.file(fileurl1, destfile="./foto.jpg")
foto<- readJPEG("./foto.jpg", native = T)
install.packages("JPEG")
install.packages("jpeg")
fileurl1="https://d396qusza40orc.cloudfront.net/getdata%2Fjeff.jpg"
download.file(fileurl1, destfile="./foto.jpg")
foto<- readJPEG("./foto.jpg", native = T)
library("jpeg", lib.loc="~/R/win-library/3.2")
library("rJava", lib.loc="~/R/win-library/3.2")
library("xlsxjars", lib.loc="~/R/win-library/3.2")
fileurl1="https://d396qusza40orc.cloudfront.net/getdata%2Fjeff.jpg"
download.file(fileurl1, destfile="./foto.jpg")
foto<- readJPEG("./foto.jpg", native = T)
cuantiles(foto, 30, 80)
quantile(foto, c(.30, .80))
quantile(foto
quantile(foto)
quantile(foto, ... )
quantile(foto, probs = seq(.03, 0.80))
quantile(foto, probs = c(.3, 0.80))
-16776939/638
-16776939*638
fileurl1="https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv"
download.file(fileurl1, destfile="./data.csv")
data <- read.csv("./data.csv")
strsplit(data, wgtp)
library("dplyr", lib.loc="~/R/win-library/3.2")
strsplit(wgtp(data), "\\.")
strsplit(names(data), "\\.")
a<-strsplit(names(data), "\\.")
a[123]
fileurl1="https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FGDP.csv "
a
fileurl1="https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FGDP.csv"
download.file(fileurl1, destfile="./data.csv")
data <- read.csv("./data.csv")
data
a<-sub(",","",data$x.3)
a
a<-sub(",","",data)
a
a<-data$X.3
a
a<-sub(",","",a)
a
sub(",","",a)
mean(a)
mean(a, na.rm = T)
mean(a[3:...], na.rm = T)
a
a<-data$X.3
a
mean(a)
a<-a[5:235]
a
mean(a)
mean(a, na.rm = T)
lapply(a, mean, na.rm = TRUE)
sapply(a, mean, na.rm = TRUE)
colmeans(a, na.rm =  TRUE)
summary(a)
mean(a[1:230])
summarise(a)
install.packages("quantmod")
library(quantmod)
amzn = getSymbols("AMZN",auto.assign=FALSE)
sampleTimes = index(amzn)
sampleTimes
weekdays(sampleTimes)
table(grepl("lunes"), weekdays(sampleTimes))
x<-weekdays(sampleTimes)
table(grepl("lunes"),x)
table(grepl("lunes",x))
table(grepl("2012"), year(sampleTimes))
table(grepl("2012"), years(sampleTimes))
table(grepl("2012"), ydm(sampleTimes))
sampleTimes
1511-1261
table(grepl("2012"), ydm(sampleTimes[1261:1511]))
table(grepl("lunes"), weekdays(sampleTimes[1261:1511]))
d<-sampleTimes[1261:1511]
table(grepl("lunes"), weekdays(d))
d
table(grepl("lunes", weekdays(d))
d
table(grepl("lunes", weekdays(d)))
install.packages("spam")
lybrary(kernlab)
install.packages("kernlab")
lybrary(kernlab)
library(kernlab)
data(spam)
head(spam)
plot(desity(spam$your[spam$type=="nonspam"]),col="blue",main="",xlab="Frequency of 'you'")
lines(density(spam$your[spam$type=="spam"]),col="red")
library(kernlab)
head(spam)
data(spam)
plot(desity(spam$your[spam$type=="nonspam"]),col="blue",main="",xlab="Frequency of 'you'")
lines(density(spam$your[spam$type=="spam"]),col="red")
library(kernlab)
head(spam)
data(spam)
plot(density(spam$your[spam$type=="nonspam"]),col="blue",main="",xlab="Frequency of 'you'")
lines(density(spam$your[spam$type=="spam"]),col="red")
prediction<-ifelse(spam$your > 0.5,"spam", "nonspam")
table(prediction,spam$type)/length(spam&type)
table(prediction,spam$type)/length(spam&type)
library(kernlab)
head(spam)
data(spam)
plot(density(spam$your[spam$type=="nonspam"]),col="blue",main="",xlab="Frequency of 'you'")
lines(density(spam$your[spam$type=="spam"]),col="red")
prediction<-ifelse(spam$your > 0.5,"spam", "nonspam")
table(prediction,spam$type)/length(spam&type)
library(kernlab)
head(spam)
data(spam)
plot(density(spam$your[spam$type=="nonspam"]),col="blue",main="",xlab="Frequency of 'you'")
lines(density(spam$your[spam$type=="spam"]),col="red")
prediction<-ifelse(spam$your > 0.5,"spam", "nonspam")
table(prediction,spam$type)
library(kernlab)
head(spam)
data(spam)
plot(density(spam$your[spam$type=="nonspam"]),col="blue",main="",xlab="Frequency of 'you'")
lines(density(spam$your[spam$type=="spam"]),col="red")
prediction<-ifelse(spam$your > 0.5,"spam", "nonspam")
table(prediction,spam$type)/length(spam$type)
%clase 2
library(kernlab)
head(spam)
data(spam)
plot(density(spam$your[spam$type=="nonspam"]),col="blue",main="",xlab="Frequency of 'you'")
lines(density(spam$your[spam$type=="spam"]),col="red")
prediction<-ifelse(spam$your > 0.5,"spam", "nonspam")
table(prediction,spam$type)/length(spam$type)
//clase 2
library(kernlab)
head(spam)
data(spam)
plot(density(spam$your[spam$type=="nonspam"]),col="blue",main="",xlab="Frequency of 'you'")
lines(density(spam$your[spam$type=="spam"]),col="red")
prediction<-ifelse(spam$your > 0.5,"spam", "nonspam")
table(prediction,spam$type)/length(spam$type)
#clase 2
library(kernlab)
head(spam)
data(spam)
plot(density(spam$your[spam$type=="nonspam"]),col="blue",main="",xlab="Frequency of 'you'")
lines(density(spam$your[spam$type=="spam"]),col="red")
prediction<-ifelse(spam$your > 0.5,"spam", "nonspam")
table(prediction,spam$type)/length(spam$type)
library(kernlab)
smallSpam<-spam[sample(dim(spam)[1],size=10),]
spamLabel<-(smallSpam$type=="spam")*1+1
plot(smallSpam$capitalAve,col=spamlabel)
library(kernlab)
smallSpam<-spam[sample(dim(spam)[1],size=10),]
spamLabel<-(smallSpam$type=="spam")*1+1
plot(smallSpam$capitalAve,col=spamLabel)
library(kernlab);data(spam);set.seed(333)
smallSpam<-spam[sample(dim(spam)[1],size=10),]
spamLabel<-(smallSpam$type=="spam")*1+1
plot(smallSpam$capitalAve,col=spamLabel)
rule1<-function(x){
prediction<-rep(NA,length(x))
prediction[x>2.7]<-"spam"
prediction[x<2.40]<-"nonspam"
prediction[(x>=2.40 & x>=2.45)]<-"spam"
prediction[(x>2.45 $ x<=2.70)]<-"nonspam"
}
rule1<-function(x){
prediction<-rep(NA,length(x))
prediction[x>2.7]<-"spam"
prediction[x<2.40]<-"nonspam"
prediction[(x>=2.40 & x<=2.45)]<-"spam"
prediction[(x>2.45 $ x<=2.70)]<-"nonspam"
}
rule1<-function(x){
prediction<-rep(NA,length(x))
prediction[x>2.7]<-"spam"
prediction[x<2.40]<-"nonspam"
prediction[(x>=2.40 & x<=2.45)]<-"spam"
prediction[(x>2.45 $ x<=2.70)]<-"nonspam"
return(prediction)
}
rule1<-function(x){
prediction<-rep(NA,length(x))
prediction[x>2.7]<-"spam"
prediction[x<2.40]<-"nonspam"
prediction[(x>=2.40 & x<=2.45)]<-"spam"
prediction[(x>2.45 & x<=2.70)]<-"nonspam"
return(prediction)
}
table(rule1(smallSpam$capitalAve),smallSpam$type)
#rule2
rule2<-function(x){
prediction<-rep(NA,length(x))
prediction[x>2.8]<-"spam"
prediction[x<=2.8]<-"nonspam"
return(prediction)
}
table(rule2(smallSpam$capitalAve),smallSpam$type)
sum(rule2(smallSpam$capitalAve)==smallSpam$type)
sum(rule1(smallSpam$capitalAve)==smallSpam)
install.packages("caret")
atrix
install.packages("pbkrtest")
library(ISLR);library(ggplot2);library(caret);
data(Wage)
summary(Wage)
install.packages("pbkrtest")
library(lattice)
library(dplyr)
library(fpc)
library(Rmixmod)
library(ggplot2)
library(cluster)
library(xlsx)
#Programa para la lectura de datos csv en R
#Empezamos leyendo el documento del cual vamos a extraer los datos:
Datos<-read.csv("PublicUSefulBankDataFurtherReduced.txt",sep=",",header=TRUE)
#creamos un fichero para saber que producto tiene cada valor
Datose<-data.frame(Datos$Product.Description)
Datose$Datos.Product.Description<-as.numeric(Datose$Datos.Product.Description)
excel<-data.frame(Datos$Product.Description, Datose$Datos.Product.Description, Datos$Spread.Rate.Nominal, Datos$Total.Rate.Nominal)
excel <- excel[!duplicated(excel[,c('Datos.Product.Description')]),]
write.xlsx(excel, "Productos_Bancarios.xlsx", sheetName="Sheet1",
col.names=TRUE, row.names=TRUE, append=FALSE, showNA=TRUE)
#we are going to select only a few variables
clients <- data.frame(Datos$Risk.Country,Datos$Customer.Code, Datos$Line.Of.Business,
Datos$Industry, Datos$Customer.Type, Datos$Profit.Center.Area,
Datos$Segment, Datos$Area, Datos$Product.Description, Datos$Spread.Rate.Nominal, Datos$Total.Rate.Nominal)
#clients <- unique(clients)
rowsOK <- complete.cases(clients)
clients <- clients[rowsOK,]
#clients <- clients[!duplicated(clients[,c('Datos.Customer.Code')]),] no importa si nos salen clientes por
#duplicado, lo que nos interesa son todas sus paquetes bancarios
clients <- filter(clients, Datos.Risk.Country=="BRAZIL");
clients$Datos.Customer.Type<-as.numeric(clients$Datos.Customer.Type)
clients$Datos.Line.Of.Business<-as.numeric(clients$Datos.Line.Of.Business)
clients$Datos.Industry<-as.numeric(clients$Datos.Industry)
clients$Datos.Area<-as.numeric(clients$Datos.Area)
clients$Datos.Profit.Center.Area<-as.numeric(clients$Datos.Profit.Center.Area)
clients$Datos.Segment<-as.numeric(clients$Datos.Segment)
clients$Datos.Product.Description<-as.numeric(clients$Datos.Product.Description)
#hacemos los clusters
dat<-select(clients,Datos.Customer.Type, Datos.Line.Of.Business,
Datos.Industry, Datos.Segment, Datos.Product.Description,Datos.Profit.Center.Area)
dat<-scale(dat)
set.seed(3)
numcenters = 5;
ClusterKmeans<-kmeans(dat,numcenters,iter.max=10,algorithm = "Forgy")
#with(clients, pairs(dat, col=c(1:20)[ClusterKmeans$cluster]))
#plotcluster(dat, clients$cluster)
#clusplot(dat, ClusterKmeans$cluster, color=TRUE, shade=TRUE, labels=2, lines=0)
Cluster1 <- data.frame(clients[(ClusterKmeans$cluster==1),])
Cluster2 <- data.frame(clients[(ClusterKmeans$cluster==2),])
Cluster3 <- data.frame(clients[(ClusterKmeans$cluster==3),])
Cluster4 <- data.frame(clients[(ClusterKmeans$cluster==4),])
Cluster5 <- data.frame(clients[(ClusterKmeans$cluster==5),])
Cluster6 <- data.frame(clients[(ClusterKmeans$cluster==6),])
Cluster7 <- data.frame(clients[(ClusterKmeans$cluster==7),])
Cluster8 <- data.frame(clients[(ClusterKmeans$cluster==8),])
Cluster9 <- data.frame(clients[(ClusterKmeans$cluster==9),])
clients_plot <- clients
levelsIndustry <-
levels(clients_plot$Datos.Industry)[-50][-49][-48]
#png(file="plot9.png")
ggplot(Cluster1,aes(Datos.Industry)) +
geom_freqpoly(data=Cluster1,color = "green", alpha = 1)+
geom_freqpoly(data=Cluster2,color = "red", alpha = 1)+
geom_freqpoly(data=Cluster3,color = "black", alpha = 1)+
geom_freqpoly(data=Cluster4,color = "blue", alpha = 1)+
geom_freqpoly(data=Cluster5,color = "yellow", alpha = 1)+
geom_freqpoly(data=Cluster6,color = "pink", alpha = 1)+
geom_freqpoly(data=Cluster7,color = "orange", alpha = 1)+
geom_freqpoly(data=Cluster8,color = "brown", alpha = 1)+
geom_freqpoly(data=Cluster9,color = "black", alpha = 1)+
scale_x_discrete(breaks=1:length(levelsIndustry),
labels=levelsIndustry)+
theme(axis.text.x = element_text(angle = 90, hjust = 1))
#Detectar cluster más poblado
Vectormayor<-nrow(data.frame(clients[(ClusterKmeans$cluster==1),]))
ClusterImportante<-data.frame(clients[(ClusterKmeans$cluster==1),])
for(i in 1:numcenters)
{
if(Vectormayor<=nrow(data.frame(clients[(ClusterKmeans$cluster==i),])))
{
Vectormayor<-nrow(data.frame(clients[(ClusterKmeans$cluster==i),]));
ClusterImportante<-data.frame(clients[(ClusterKmeans$cluster==i),]);
}
}
#UsuariosCluster<-ClusterImportante$Datos.Customer.Code;
#Cluster con picos más poblados
Productos_cluster<-sort(table(ClusterImportante$Datos.Product.Description))
#Creamos una tabla
#ClusterFinal<-data.frame(Datos$Risk.Country,Datos$Customer.Code, Datos$Line.Of.Business,
#Datos$Industry, Datos$Customer.Type, Datos$Profit.Center.Area,
#Datos$Segment, Datos$Area, Datos$Product.Description,Datos$Base.Rate.Nominal,
#Datos$Spread.Rate.Nominal, Datos$Total.Rate.Nominal);
#for(i=)
#ClusterFinal <- filter(ClusterFinal, Datos.Customer.Code==UsuariosCluster);
#NumPrd variable que contiene cuantos productos parecidos hay
#hay que guardar en un data.frame las empresas que solo tienen
#los productos por debajo del mejor
#Up-selling
#Si(NUmPrd >=2){
#}
#Cross-selling
#if(NUmPrd = 0){
#comprobar que empresas del producto más poblado no tienen los dos siguientes
#mostrará los dos productos siguientes ha recomendar en un arxivo xlm
#}
setwd("O:/Proyecto de fin de Grado/TFG/TFG")
library(lattice)
library(dplyr)
library(fpc)
library(Rmixmod)
library(ggplot2)
library(cluster)
library(xlsx)
#Programa para la lectura de datos csv en R
#Empezamos leyendo el documento del cual vamos a extraer los datos:
Datos<-read.csv("PublicUSefulBankDataFurtherReduced.txt",sep=",",header=TRUE)
#creamos un fichero para saber que producto tiene cada valor
Datose<-data.frame(Datos$Product.Description)
Datose$Datos.Product.Description<-as.numeric(Datose$Datos.Product.Description)
excel<-data.frame(Datos$Product.Description, Datose$Datos.Product.Description, Datos$Spread.Rate.Nominal, Datos$Total.Rate.Nominal)
excel <- excel[!duplicated(excel[,c('Datos.Product.Description')]),]
write.xlsx(excel, "Productos_Bancarios.xlsx", sheetName="Sheet1",
col.names=TRUE, row.names=TRUE, append=FALSE, showNA=TRUE)
#we are going to select only a few variables
clients <- data.frame(Datos$Risk.Country,Datos$Customer.Code, Datos$Line.Of.Business,
Datos$Industry, Datos$Customer.Type, Datos$Profit.Center.Area,
Datos$Segment, Datos$Area, Datos$Product.Description, Datos$Spread.Rate.Nominal, Datos$Total.Rate.Nominal)
#clients <- unique(clients)
rowsOK <- complete.cases(clients)
clients <- clients[rowsOK,]
#clients <- clients[!duplicated(clients[,c('Datos.Customer.Code')]),] no importa si nos salen clientes por
#duplicado, lo que nos interesa son todas sus paquetes bancarios
clients <- filter(clients, Datos.Risk.Country=="BRAZIL");
clients$Datos.Customer.Type<-as.numeric(clients$Datos.Customer.Type)
clients$Datos.Line.Of.Business<-as.numeric(clients$Datos.Line.Of.Business)
clients$Datos.Industry<-as.numeric(clients$Datos.Industry)
clients$Datos.Area<-as.numeric(clients$Datos.Area)
clients$Datos.Profit.Center.Area<-as.numeric(clients$Datos.Profit.Center.Area)
clients$Datos.Segment<-as.numeric(clients$Datos.Segment)
clients$Datos.Product.Description<-as.numeric(clients$Datos.Product.Description)
#hacemos los clusters
dat<-select(clients,Datos.Customer.Type, Datos.Line.Of.Business,
Datos.Industry, Datos.Segment, Datos.Product.Description,Datos.Profit.Center.Area)
dat<-scale(dat)
set.seed(3)
numcenters = 5;
ClusterKmeans<-kmeans(dat,numcenters,iter.max=10,algorithm = "Forgy")
#with(clients, pairs(dat, col=c(1:20)[ClusterKmeans$cluster]))
#plotcluster(dat, clients$cluster)
#clusplot(dat, ClusterKmeans$cluster, color=TRUE, shade=TRUE, labels=2, lines=0)
Cluster1 <- data.frame(clients[(ClusterKmeans$cluster==1),])
Cluster2 <- data.frame(clients[(ClusterKmeans$cluster==2),])
Cluster3 <- data.frame(clients[(ClusterKmeans$cluster==3),])
Cluster4 <- data.frame(clients[(ClusterKmeans$cluster==4),])
Cluster5 <- data.frame(clients[(ClusterKmeans$cluster==5),])
Cluster6 <- data.frame(clients[(ClusterKmeans$cluster==6),])
Cluster7 <- data.frame(clients[(ClusterKmeans$cluster==7),])
Cluster8 <- data.frame(clients[(ClusterKmeans$cluster==8),])
Cluster9 <- data.frame(clients[(ClusterKmeans$cluster==9),])
clients_plot <- clients
levelsIndustry <-
levels(clients_plot$Datos.Industry)[-50][-49][-48]
#png(file="plot9.png")
ggplot(Cluster1,aes(Datos.Industry)) +
geom_freqpoly(data=Cluster1,color = "green", alpha = 1)+
geom_freqpoly(data=Cluster2,color = "red", alpha = 1)+
geom_freqpoly(data=Cluster3,color = "black", alpha = 1)+
geom_freqpoly(data=Cluster4,color = "blue", alpha = 1)+
geom_freqpoly(data=Cluster5,color = "yellow", alpha = 1)+
geom_freqpoly(data=Cluster6,color = "pink", alpha = 1)+
geom_freqpoly(data=Cluster7,color = "orange", alpha = 1)+
geom_freqpoly(data=Cluster8,color = "brown", alpha = 1)+
geom_freqpoly(data=Cluster9,color = "black", alpha = 1)+
scale_x_discrete(breaks=1:length(levelsIndustry),
labels=levelsIndustry)+
theme(axis.text.x = element_text(angle = 90, hjust = 1))
#Detectar cluster más poblado
Vectormayor<-nrow(data.frame(clients[(ClusterKmeans$cluster==1),]))
ClusterImportante<-data.frame(clients[(ClusterKmeans$cluster==1),])
for(i in 1:numcenters)
{
if(Vectormayor<=nrow(data.frame(clients[(ClusterKmeans$cluster==i),])))
{
Vectormayor<-nrow(data.frame(clients[(ClusterKmeans$cluster==i),]));
ClusterImportante<-data.frame(clients[(ClusterKmeans$cluster==i),]);
}
}
#UsuariosCluster<-ClusterImportante$Datos.Customer.Code;
#Cluster con picos más poblados
Productos_cluster<-sort(table(ClusterImportante$Datos.Product.Description))
#Creamos una tabla
#ClusterFinal<-data.frame(Datos$Risk.Country,Datos$Customer.Code, Datos$Line.Of.Business,
#Datos$Industry, Datos$Customer.Type, Datos$Profit.Center.Area,
#Datos$Segment, Datos$Area, Datos$Product.Description,Datos$Base.Rate.Nominal,
#Datos$Spread.Rate.Nominal, Datos$Total.Rate.Nominal);
#for(i=)
#ClusterFinal <- filter(ClusterFinal, Datos.Customer.Code==UsuariosCluster);
#NumPrd variable que contiene cuantos productos parecidos hay
#hay que guardar en un data.frame las empresas que solo tienen
#los productos por debajo del mejor
#Up-selling
#Si(NUmPrd >=2){
#}
#Cross-selling
#if(NUmPrd = 0){
#comprobar que empresas del producto más poblado no tienen los dos siguientes
#mostrará los dos productos siguientes ha recomendar en un arxivo xlm
#}
#hacemos los clusters
dat<-select(clients,Datos.Customer.Type, Datos.Line.Of.Business,
Datos.Industry, Datos.Segment, Datos.Product.Description,Datos.Profit.Center.Area,Datos.Area)
dat<-scale(dat)
set.seed(3)
numcenters = 5;
ClusterKmeans<-kmeans(dat,numcenters,iter.max=10,algorithm = "Forgy")
#with(clients, pairs(dat, col=c(1:20)[ClusterKmeans$cluster]))
#plotcluster(dat, clients$cluster)
#clusplot(dat, ClusterKmeans$cluster, color=TRUE, shade=TRUE, labels=2, lines=0)
Cluster1 <- data.frame(clients[(ClusterKmeans$cluster==1),])
Cluster2 <- data.frame(clients[(ClusterKmeans$cluster==2),])
Cluster3 <- data.frame(clients[(ClusterKmeans$cluster==3),])
Cluster4 <- data.frame(clients[(ClusterKmeans$cluster==4),])
Cluster5 <- data.frame(clients[(ClusterKmeans$cluster==5),])
Cluster6 <- data.frame(clients[(ClusterKmeans$cluster==6),])
Cluster7 <- data.frame(clients[(ClusterKmeans$cluster==7),])
Cluster8 <- data.frame(clients[(ClusterKmeans$cluster==8),])
Cluster9 <- data.frame(clients[(ClusterKmeans$cluster==9),])
clients_plot <- clients
levelsIndustry <-
levels(clients_plot$Datos.Industry)[-50][-49][-48]
#png(file="plot9.png")
ggplot(Cluster1,aes(Datos.Industry)) +
geom_freqpoly(data=Cluster1,color = "green", alpha = 1)+
geom_freqpoly(data=Cluster2,color = "red", alpha = 1)+
geom_freqpoly(data=Cluster3,color = "black", alpha = 1)+
geom_freqpoly(data=Cluster4,color = "blue", alpha = 1)+
geom_freqpoly(data=Cluster5,color = "yellow", alpha = 1)+
geom_freqpoly(data=Cluster6,color = "pink", alpha = 1)+
geom_freqpoly(data=Cluster7,color = "orange", alpha = 1)+
geom_freqpoly(data=Cluster8,color = "brown", alpha = 1)+
geom_freqpoly(data=Cluster9,color = "black", alpha = 1)+
scale_x_discrete(breaks=1:length(levelsIndustry),
labels=levelsIndustry)+
theme(axis.text.x = element_text(angle = 90, hjust = 1))
#Detectar cluster más poblado
Vectormayor<-nrow(data.frame(clients[(ClusterKmeans$cluster==1),]))
ClusterImportante<-data.frame(clients[(ClusterKmeans$cluster==1),])
for(i in 1:numcenters)
{
if(Vectormayor<=nrow(data.frame(clients[(ClusterKmeans$cluster==i),])))
{
Vectormayor<-nrow(data.frame(clients[(ClusterKmeans$cluster==i),]));
ClusterImportante<-data.frame(clients[(ClusterKmeans$cluster==i),]);
}
}
#UsuariosCluster<-ClusterImportante$Datos.Customer.Code;
#Cluster con picos más poblados
Productos_cluster<-sort(table(ClusterImportante$Datos.Product.Description))
#Creamos una tabla
#ClusterFinal<-data.frame(Datos$Risk.Country,Datos$Customer.Code, Datos$Line.Of.Business,
#Datos$Industry, Datos$Customer.Type, Datos$Profit.Center.Area,
#Datos$Segment, Datos$Area, Datos$Product.Description,Datos$Base.Rate.Nominal,
#Datos$Spread.Rate.Nominal, Datos$Total.Rate.Nominal);
#for(i=)
#ClusterFinal <- filter(ClusterFinal, Datos.Customer.Code==UsuariosCluster);
#NumPrd variable que contiene cuantos productos parecidos hay
#hay que guardar en un data.frame las empresas que solo tienen
#los productos por debajo del mejor
#Up-selling
#Si(NUmPrd >=2){
#}
#Cross-selling
#if(NUmPrd = 0){
#comprobar que empresas del producto más poblado no tienen los dos siguientes
#mostrará los dos productos siguientes ha recomendar en un arxivo xlm
#}
Productos_cluster<-sort(table(ClusterImportante$Datos.Product.Description))
Productos_cluster<-sort(table(data.frame(ClusterImportante$Datos.Product.Description)))
Productos_cluster<-data.frame(sort(table(ClusterImportante$Datos.Product.Description)))
View(Productos_cluster)
Productos_cluster[1]
View(Productos_cluster)
View(clients_plot)
